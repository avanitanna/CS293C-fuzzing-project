[('__init__', <function HTMLParser.__init__ at 0x7fd6ae2f9430>), ('_parse', <function HTMLParser._parse at 0x7fd6ae2f94c0>), ('adjustForeignAttributes', <function HTMLParser.adjustForeignAttributes at 0x7fd6ae2f9af0>), ('adjustMathMLAttributes', <function HTMLParser.adjustMathMLAttributes at 0x7fd6ae2f99d0>), ('adjustSVGAttributes', <function HTMLParser.adjustSVGAttributes at 0x7fd6ae2f9a60>), ('isHTMLIntegrationPoint', <function HTMLParser.isHTMLIntegrationPoint at 0x7fd6ae2f9670>), ('isMathMLTextIntegrationPoint', <function HTMLParser.isMathMLTextIntegrationPoint at 0x7fd6ae2f9700>), ('mainLoop', <function HTMLParser.mainLoop at 0x7fd6ae2f9790>), ('parse', <function HTMLParser.parse at 0x7fd6ae2f9820>), ('parseError', <function HTMLParser.parseError at 0x7fd6ae2f9940>), ('parseFragment', <function HTMLParser.parseFragment at 0x7fd6ae2f98b0>), ('parseRCDataRawtext', <function HTMLParser.parseRCDataRawtext at 0x7fd6ae2f9ca0>), ('reparseTokenNormal', <function HTMLParser.reparseTokenNormal at 0x7fd6ae2f9b80>), ('reset', <function HTMLParser.reset at 0x7fd6ae2f9550>), ('resetInsertionMode', <function HTMLParser.resetInsertionMode at 0x7fd6ae2f9c10>)]
[('copy', <function copy at 0x7fd6bd21d280>), ('getETreeBuilder', <function getETreeBuilder at 0x7fd6ae2a4310>), ('getETreeModule', <function moduleFactoryFactory.<locals>.moduleFactory at 0x7fd6ae2a4940>), ('moduleFactoryFactory', <function moduleFactoryFactory at 0x7fd6ae382940>)]
[('HTMLInputStream', <function HTMLInputStream at 0x7fd6ba7cef70>)]
__init__
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
return

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    return
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    return

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            return
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            return
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            return
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                return
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                return
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            return
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            return
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            return

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                return
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                return
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            return
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            return

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        return

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            return
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            return

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        return

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            return
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            return
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        return
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        return
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    return
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        return

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            return
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            return
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                return
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        return

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            return
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            return
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            return
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            return

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            return
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            return
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            return

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            return
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            return
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            return

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    return
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                return
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    return
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                return
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                return
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                return
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        return
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    return
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        return
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    return

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            return
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                return
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                return
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    return
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    return
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            return
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            return

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            return
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            return
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            return
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            return

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            return
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        return

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            return
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            return
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            return
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            return

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                return
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        return

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                return
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        return

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            return

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            return

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        return

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                return
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    return
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    return
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    return
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    return
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                return
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    return
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    return
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    return
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                return
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                return
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                return
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    return
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    return
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    return
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    return
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                return
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    return
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        return
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            return
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            return
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            return
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            return
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        return
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        return
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    return
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            return
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                return
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                return
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        return
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        return
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        return
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        return

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                return
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    return
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    return
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    return
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    return
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    return
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    return
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    return
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    return
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                return
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    return
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    return
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    return
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    return
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    return
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                return
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                return
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        return
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        return
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        return
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        return
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        return
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        return
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        return

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return
    return locals()
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return
getETreeModule = moduleFactoryFactory(getETreeBuilder)
from __future__ import absolute_import, division, unicode_literals
from six import text_type
import re
from copy import copy
from . import base
from .. import _ihatexml
from .. import constants
from ..constants import namespaces
from .._utils import moduleFactoryFactory
tag_regexp = re.compile('{([^}]*)}(.*)')

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment('asd').tag

    class Element(base.Node):

        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name, namespace))
            if namespace is None:
                self.nameTuple = (namespaces['html'], self._name)
            else:
                self.nameTuple = (self._namespace, self._name)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = '{%s}%s' % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace
        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            el_attrib = self._element.attrib
            el_attrib.clear()
            if attributes:
                for (key, value) in attributes.items():
                    if isinstance(key, tuple):
                        name = '{%s}%s' % (key[2], key[1])
                    else:
                        name = key
                    el_attrib[name] = value
        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._childNodes.remove(node)
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not len(self._element):
                if not self._element.text:
                    self._element.text = ''
                self._element.text += data
            elif insertBefore is None:
                if not self._element[-1].tail:
                    self._element[-1].tail = ''
                self._element[-1].tail += data
            else:
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ''
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ''
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            if self._element.attrib:
                element._element.attrib = copy(self._element.attrib)
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ''
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ''
            base.Node.reparentChildren(self, newParent)

    class Comment(Element):

        def __init__(self, data):
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value
        data = property(_getData, _setData)

    class DocumentType(Element):

        def __init__(self, name, publicId, systemId):
            Element.__init__(self, '<!DOCTYPE>')
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get('publicId', '')

        def _setPublicId(self, value):
            if value is not None:
                self._element.set('publicId', value)
        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get('systemId', '')

        def _setSystemId(self, value):
            if value is not None:
                self._element.set('systemId', value)
        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_ROOT')

    class DocumentFragment(Element):

        def __init__(self):
            Element.__init__(self, 'DOCUMENT_FRAGMENT')

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not hasattr(element, 'tag'):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                rv.append('#document')
                if element.text is not None:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
            elif element.tag == ElementTreeCommentType:
                rv.append('|%s<!-- %s -->' % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), 'Expected unicode, got %s, %s' % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)
                if nsmatch is None:
                    name = element.tag
                else:
                    (ns, name) = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = '%s %s' % (prefix, name)
                rv.append('|%s<%s>' % (' ' * indent, name))
                if hasattr(element, 'attrib'):
                    attributes = []
                    for (name, value) in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            (ns, name) = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = '%s %s' % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))
                    for (name, value) in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append('|%s"%s"' % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append('|%s"%s"' % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)
        return '\n'.join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = _ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()
            if element.tag == '<!DOCTYPE>':
                if element.get('publicId') or element.get('systemId'):
                    publicId = element.get('publicId') or ''
                    systemId = element.get('systemId') or ''
                    rv.append('<!DOCTYPE %s PUBLIC "%s" "%s">' % (element.text, publicId, systemId))
                else:
                    rv.append('<!DOCTYPE %s>' % (element.text,))
            elif element.tag == 'DOCUMENT_ROOT':
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError('Document node cannot have tail')
                if hasattr(element, 'attrib') and len(element.attrib):
                    raise TypeError('Document node cannot have attributes')
                for child in element:
                    serializeElement(child)
            elif element.tag == ElementTreeCommentType:
                rv.append('<!--%s-->' % (element.text,))
            else:
                if not element.attrib:
                    rv.append('<%s>' % (filter.fromXmlName(element.tag),))
                else:
                    attr = ' '.join(['%s="%s"' % (filter.fromXmlName(name), value) for (name, value) in element.attrib.items()])
                    rv.append('<%s %s>' % (element.tag, attr))
                if element.text:
                    rv.append(element.text)
                for child in element:
                    serializeElement(child)
                rv.append('</%s>' % (element.tag,))
            if element.tail:
                rv.append(element.tail)
        serializeElement(element)
        return ''.join(rv)

    class TreeBuilder(base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            elif self.defaultNamespace is not None:
                return self.document._element.find('{%s}html' % self.defaultNamespace)
            else:
                return self.document._element.find('html')

        def getFragment(self):
            return base.TreeBuilder.getFragment(self)._element
    return locals()
return
